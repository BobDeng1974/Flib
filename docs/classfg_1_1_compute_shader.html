<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Flib: fg::ComputeShader Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Flib
   &#160;<span id="projectnumber">1.1b</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacefg.html">fg</a></li><li class="navelem"><a class="el" href="classfg_1_1_compute_shader.html">ComputeShader</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="classfg_1_1_compute_shader-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">fg::ComputeShader Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="_compute_shader_8hpp_source.html">ComputeShader.hpp</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for fg::ComputeShader:</div>
<div class="dyncontent">
<div class="center"><img src="classfg_1_1_compute_shader__inherit__graph.png" border="0" usemap="#fg_1_1_compute_shader_inherit__map" alt="Inheritance graph"/></div>
<map name="fg_1_1_compute_shader_inherit__map" id="fg_1_1_compute_shader_inherit__map">
<area shape="rect" id="node2" href="classfg_1_1_gl_object.html" title="Base class for opengl objects that have id such as texture, shader etc. " alt="" coords="27,5,117,32"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a634948dc3fcdc057ea899190a6f102b4"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classfg_1_1_compute_shader.html">ComputeShader</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfg_1_1_compute_shader.html#a634948dc3fcdc057ea899190a6f102b4">reference</a></td></tr>
<tr class="separator:a634948dc3fcdc057ea899190a6f102b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec3751145b5825ef967eedf6e4e57183"><td class="memItemLeft" align="right" valign="top">typedef const <a class="el" href="classfg_1_1_compute_shader.html">ComputeShader</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfg_1_1_compute_shader.html#aec3751145b5825ef967eedf6e4e57183">const_reference</a></td></tr>
<tr class="separator:aec3751145b5825ef967eedf6e4e57183"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ad05555d234c9ae11c6041902ba683fd1"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfg_1_1_compute_shader.html#ad05555d234c9ae11c6041902ba683fd1">ComputeShader</a> ()</td></tr>
<tr class="memdesc:ad05555d234c9ae11c6041902ba683fd1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor.  <a href="#ad05555d234c9ae11c6041902ba683fd1">More...</a><br /></td></tr>
<tr class="separator:ad05555d234c9ae11c6041902ba683fd1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab437560a40823c0fafee978c5337c2a8"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfg_1_1_compute_shader.html#ab437560a40823c0fafee978c5337c2a8">ComputeShader</a> (<a class="el" href="classfg_1_1_compute_shader.html">ComputeShader</a> &amp;&amp;shader)</td></tr>
<tr class="memdesc:ab437560a40823c0fafee978c5337c2a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move constructor.  <a href="#ab437560a40823c0fafee978c5337c2a8">More...</a><br /></td></tr>
<tr class="separator:ab437560a40823c0fafee978c5337c2a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad669885b897a14fbf1ad3801a70f503a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classfg_1_1_compute_shader.html">ComputeShader</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfg_1_1_compute_shader.html#ad669885b897a14fbf1ad3801a70f503a">operator=</a> (<a class="el" href="classfg_1_1_compute_shader.html">ComputeShader</a> &amp;&amp;shader)</td></tr>
<tr class="memdesc:ad669885b897a14fbf1ad3801a70f503a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move assignment operator.  <a href="#ad669885b897a14fbf1ad3801a70f503a">More...</a><br /></td></tr>
<tr class="separator:ad669885b897a14fbf1ad3801a70f503a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77d66de52195d4c9ba94e91afc1d9c14"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classfg_1_1_compute_shader.html">ComputeShader</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfg_1_1_compute_shader.html#a77d66de52195d4c9ba94e91afc1d9c14">swap</a> (<a class="el" href="classfg_1_1_compute_shader.html">ComputeShader</a> &amp;shader)</td></tr>
<tr class="memdesc:a77d66de52195d4c9ba94e91afc1d9c14"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swap two shaders.  <a href="#a77d66de52195d4c9ba94e91afc1d9c14">More...</a><br /></td></tr>
<tr class="separator:a77d66de52195d4c9ba94e91afc1d9c14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27f461d549bd364326c32cf5af208632"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfg_1_1_compute_shader.html#a27f461d549bd364326c32cf5af208632">~ComputeShader</a> ()</td></tr>
<tr class="memdesc:a27f461d549bd364326c32cf5af208632"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default destructor.  <a href="#a27f461d549bd364326c32cf5af208632">More...</a><br /></td></tr>
<tr class="separator:a27f461d549bd364326c32cf5af208632"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c8e257419912d708a9520c2e2333091"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classfm_1_1_result.html">fm::Result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfg_1_1_compute_shader.html#a6c8e257419912d708a9520c2e2333091">loadFromFile</a> (const std::string &amp;file)</td></tr>
<tr class="memdesc:a6c8e257419912d708a9520c2e2333091"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load the compute shader program a file.  <a href="#a6c8e257419912d708a9520c2e2333091">More...</a><br /></td></tr>
<tr class="separator:a6c8e257419912d708a9520c2e2333091"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1248a709052227d88134cb066c71e87"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classfm_1_1_result.html">fm::Result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfg_1_1_compute_shader.html#af1248a709052227d88134cb066c71e87">loadFromMemory</a> (const std::string &amp;data)</td></tr>
<tr class="memdesc:af1248a709052227d88134cb066c71e87"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load the compute shader program from source stored in memory.  <a href="#af1248a709052227d88134cb066c71e87">More...</a><br /></td></tr>
<tr class="separator:af1248a709052227d88134cb066c71e87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8792266bde6a0d5d107dea5601ea6e5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classfm_1_1_result.html">fm::Result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfg_1_1_compute_shader.html#ae8792266bde6a0d5d107dea5601ea6e5">loadFromMemory</a> (const <a class="el" href="classfg_1_1_shader_source.html">fg::ShaderSource</a> &amp;data)</td></tr>
<tr class="memdesc:ae8792266bde6a0d5d107dea5601ea6e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load the shader program from source stored in memory.  <a href="#ae8792266bde6a0d5d107dea5601ea6e5">More...</a><br /></td></tr>
<tr class="separator:ae8792266bde6a0d5d107dea5601ea6e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63dd54d7c3631c6e341e6ee6d694f3a8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfg_1_1_compute_shader.html#a63dd54d7c3631c6e341e6ee6d694f3a8">bind</a> () const</td></tr>
<tr class="memdesc:a63dd54d7c3631c6e341e6ee6d694f3a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bind the shader program for usage.  <a href="#a63dd54d7c3631c6e341e6ee6d694f3a8">More...</a><br /></td></tr>
<tr class="separator:a63dd54d7c3631c6e341e6ee6d694f3a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e77019323d52eb5457aa855d092200f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfg_1_1_compute_shader.html#a4e77019323d52eb5457aa855d092200f">getUniformLocation</a> (const std::string &amp;name)</td></tr>
<tr class="memdesc:a4e77019323d52eb5457aa855d092200f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the "id" of a uniform.  <a href="#a4e77019323d52eb5457aa855d092200f">More...</a><br /></td></tr>
<tr class="separator:a4e77019323d52eb5457aa855d092200f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82729561f71c815baf6491980d791815"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfg_1_1_compute_shader.html#a82729561f71c815baf6491980d791815">fillUniformData</a> ()</td></tr>
<tr class="memdesc:a82729561f71c815baf6491980d791815"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fill the necessary data about uniforms.  <a href="#a82729561f71c815baf6491980d791815">More...</a><br /></td></tr>
<tr class="separator:a82729561f71c815baf6491980d791815"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98efaa7fe75be0bff72bdc3acd22d180"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfg_1_1_compute_shader.html#a98efaa7fe75be0bff72bdc3acd22d180">hasUniform</a> (const std::string &amp;name)</td></tr>
<tr class="memdesc:a98efaa7fe75be0bff72bdc3acd22d180"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if a uniform of a given name is present.  <a href="#a98efaa7fe75be0bff72bdc3acd22d180">More...</a><br /></td></tr>
<tr class="separator:a98efaa7fe75be0bff72bdc3acd22d180"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ab46a0a679fb6a553c65368d3b87944"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a5ab46a0a679fb6a553c65368d3b87944"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classfm_1_1_result.html">fm::Result</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classfg_1_1_compute_shader.html#a5ab46a0a679fb6a553c65368d3b87944">setUniform</a> (const std::string &amp;name, const T &amp;x)</td></tr>
<tr class="memdesc:a5ab46a0a679fb6a553c65368d3b87944"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the value of a uniform.  <a href="#a5ab46a0a679fb6a553c65368d3b87944">More...</a><br /></td></tr>
<tr class="separator:a5ab46a0a679fb6a553c65368d3b87944"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d78a03174d8c13226ffa08bcaf33a6a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classfm_1_1_result.html">fm::Result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfg_1_1_compute_shader.html#a1d78a03174d8c13226ffa08bcaf33a6a">setUniform</a> (const std::string &amp;name, const <a class="el" href="classfg_1_1_texture.html">Texture</a> &amp;tex, bool sampler=false)</td></tr>
<tr class="memdesc:a1d78a03174d8c13226ffa08bcaf33a6a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the value of an image2D uniform.  <a href="#a1d78a03174d8c13226ffa08bcaf33a6a">More...</a><br /></td></tr>
<tr class="separator:a1d78a03174d8c13226ffa08bcaf33a6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39c8d13ba2bc78d7981ff1409342296d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classfm_1_1_result.html">fm::Result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfg_1_1_compute_shader.html#a39c8d13ba2bc78d7981ff1409342296d">setUniform</a> (const std::string &amp;name, const <a class="el" href="classfg_1_1_texture.html">Texture</a> *tex, bool sampler=false)</td></tr>
<tr class="memdesc:a39c8d13ba2bc78d7981ff1409342296d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the value of an image2D uniform.  <a href="#a39c8d13ba2bc78d7981ff1409342296d">More...</a><br /></td></tr>
<tr class="separator:a39c8d13ba2bc78d7981ff1409342296d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad22352eb998cea97b28f9d7e05274b5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classfm_1_1_result.html">fm::Result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfg_1_1_compute_shader.html#aad22352eb998cea97b28f9d7e05274b5">setUniform</a> (const std::string &amp;name, const <a class="el" href="classfg_1_1_float_texture.html">FloatTexture</a> &amp;tex, bool sampler=false)</td></tr>
<tr class="memdesc:aad22352eb998cea97b28f9d7e05274b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the value of an image2D uniform.  <a href="#aad22352eb998cea97b28f9d7e05274b5">More...</a><br /></td></tr>
<tr class="separator:aad22352eb998cea97b28f9d7e05274b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8260c7c3f1716de8d17414f9f249d696"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classfm_1_1_result.html">fm::Result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfg_1_1_compute_shader.html#a8260c7c3f1716de8d17414f9f249d696">setUniform</a> (const std::string &amp;name, const <a class="el" href="classfg_1_1_float_texture.html">FloatTexture</a> *tex, bool sampler=false)</td></tr>
<tr class="memdesc:a8260c7c3f1716de8d17414f9f249d696"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the value of an image2D uniform.  <a href="#a8260c7c3f1716de8d17414f9f249d696">More...</a><br /></td></tr>
<tr class="separator:a8260c7c3f1716de8d17414f9f249d696"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e4a22f8fdfa17576eb83ec3c7b62da2"><td class="memTemplParams" colspan="2">template&lt;class T , fm::Size N&gt; </td></tr>
<tr class="memitem:a5e4a22f8fdfa17576eb83ec3c7b62da2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classfm_1_1_result.html">fm::Result</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classfg_1_1_compute_shader.html#a5e4a22f8fdfa17576eb83ec3c7b62da2">setUniform</a> (const std::string &amp;name, const T(&amp;values)[N])</td></tr>
<tr class="memdesc:a5e4a22f8fdfa17576eb83ec3c7b62da2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the value of an array of uniforms.  <a href="#a5e4a22f8fdfa17576eb83ec3c7b62da2">More...</a><br /></td></tr>
<tr class="separator:a5e4a22f8fdfa17576eb83ec3c7b62da2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b03c6eb607d94d1c0d3fdc13cfdb51a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfg_1_1_compute_shader.html#a6b03c6eb607d94d1c0d3fdc13cfdb51a">forEachUniform</a> (<a class="el" href="classfm_1_1_delegate.html">fm::Delegate</a>&lt; void, std::string, <a class="el" href="classfg_1_1_shader.html#a97563a9ceb26ef3bf1db54887026d15c">Shader::UniformData</a> &gt; func) const</td></tr>
<tr class="memdesc:a6b03c6eb607d94d1c0d3fdc13cfdb51a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Run a function on all uniforms.  <a href="#a6b03c6eb607d94d1c0d3fdc13cfdb51a">More...</a><br /></td></tr>
<tr class="separator:a6b03c6eb607d94d1c0d3fdc13cfdb51a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab189cfe837819f456b35b9458a78b26f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfg_1_1_compute_shader.html#ab189cfe837819f456b35b9458a78b26f">isLoaded</a> () const</td></tr>
<tr class="memdesc:ab189cfe837819f456b35b9458a78b26f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the shader is successfully loaded.  <a href="#ab189cfe837819f456b35b9458a78b26f">More...</a><br /></td></tr>
<tr class="separator:ab189cfe837819f456b35b9458a78b26f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a548745d90ea6a5127e1ad75b93f95f50"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classfm_1_1_result.html">fm::Result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfg_1_1_compute_shader.html#a548745d90ea6a5127e1ad75b93f95f50">run</a> (<a class="el" href="namespacefm.html#aa61d3cedb1b9d93557d0402c8ee9ea64">fm::vec3s</a> workGroupDims) const</td></tr>
<tr class="memdesc:a548745d90ea6a5127e1ad75b93f95f50"><td class="mdescLeft">&#160;</td><td class="mdescRight">run The shader once with given work group dimensions  <a href="#a548745d90ea6a5127e1ad75b93f95f50">More...</a><br /></td></tr>
<tr class="separator:a548745d90ea6a5127e1ad75b93f95f50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54b1ef2b21de8cac1b5f50e4b06a7795"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classfm_1_1_result.html">fm::Result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfg_1_1_compute_shader.html#a54b1ef2b21de8cac1b5f50e4b06a7795">dispatch</a> (<a class="el" href="namespacefm.html#aa61d3cedb1b9d93557d0402c8ee9ea64">fm::vec3s</a> workGroupDims) const</td></tr>
<tr class="memdesc:a54b1ef2b21de8cac1b5f50e4b06a7795"><td class="mdescLeft">&#160;</td><td class="mdescRight">run The shader once with given work group dimensions  <a href="#a54b1ef2b21de8cac1b5f50e4b06a7795">More...</a><br /></td></tr>
<tr class="separator:a54b1ef2b21de8cac1b5f50e4b06a7795"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classfg_1_1_gl_object"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classfg_1_1_gl_object')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classfg_1_1_gl_object.html">fg::GlObject</a></td></tr>
<tr class="memitem:a3f7170956dad6d853e0d22c686a9fc96 inherit pub_methods_classfg_1_1_gl_object"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfg_1_1_gl_object.html#a3f7170956dad6d853e0d22c686a9fc96">GlObject</a> ()</td></tr>
<tr class="memdesc:a3f7170956dad6d853e0d22c686a9fc96 inherit pub_methods_classfg_1_1_gl_object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor.  <a href="classfg_1_1_gl_object.html#a3f7170956dad6d853e0d22c686a9fc96">More...</a><br /></td></tr>
<tr class="separator:a3f7170956dad6d853e0d22c686a9fc96 inherit pub_methods_classfg_1_1_gl_object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21eae7cdcfef2e129a2b1e581601d541 inherit pub_methods_classfg_1_1_gl_object"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfg_1_1_gl_object.html#a21eae7cdcfef2e129a2b1e581601d541">~GlObject</a> ()</td></tr>
<tr class="memdesc:a21eae7cdcfef2e129a2b1e581601d541 inherit pub_methods_classfg_1_1_gl_object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Virtual destructor.  <a href="classfg_1_1_gl_object.html#a21eae7cdcfef2e129a2b1e581601d541">More...</a><br /></td></tr>
<tr class="separator:a21eae7cdcfef2e129a2b1e581601d541 inherit pub_methods_classfg_1_1_gl_object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3b12a1bf39d7693522b1787f8cc9bc0 inherit pub_methods_classfg_1_1_gl_object"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacefm.html#ae661eac5c0fb8a9d00e5682533173a38">fm::Uint32</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfg_1_1_gl_object.html#ab3b12a1bf39d7693522b1787f8cc9bc0">getGlId</a> ()</td></tr>
<tr class="memdesc:ab3b12a1bf39d7693522b1787f8cc9bc0 inherit pub_methods_classfg_1_1_gl_object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get rw access to the id.  <a href="classfg_1_1_gl_object.html#ab3b12a1bf39d7693522b1787f8cc9bc0">More...</a><br /></td></tr>
<tr class="separator:ab3b12a1bf39d7693522b1787f8cc9bc0 inherit pub_methods_classfg_1_1_gl_object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24f4e189cbc5e57a63c1d2573656a5ae inherit pub_methods_classfg_1_1_gl_object"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespacefm.html#ae661eac5c0fb8a9d00e5682533173a38">fm::Uint32</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfg_1_1_gl_object.html#a24f4e189cbc5e57a63c1d2573656a5ae">getGlId</a> () const</td></tr>
<tr class="memdesc:a24f4e189cbc5e57a63c1d2573656a5ae inherit pub_methods_classfg_1_1_gl_object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get read-only access to the id.  <a href="classfg_1_1_gl_object.html#a24f4e189cbc5e57a63c1d2573656a5ae">More...</a><br /></td></tr>
<tr class="separator:a24f4e189cbc5e57a63c1d2573656a5ae inherit pub_methods_classfg_1_1_gl_object"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a7454a834dcccc520d3d7e92dc0872dc6"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfg_1_1_compute_shader.html#a7454a834dcccc520d3d7e92dc0872dc6">bind</a> (<a class="el" href="classfm_1_1_ref.html">fm::Ref</a>&lt; const <a class="el" href="classfg_1_1_compute_shader.html">ComputeShader</a> &gt; program)</td></tr>
<tr class="memdesc:a7454a834dcccc520d3d7e92dc0872dc6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bind a compute shader program for usage.  <a href="#a7454a834dcccc520d3d7e92dc0872dc6">More...</a><br /></td></tr>
<tr class="separator:a7454a834dcccc520d3d7e92dc0872dc6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3a993de1cf57b8c3f19f2763bd92285"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfg_1_1_compute_shader.html#ae3a993de1cf57b8c3f19f2763bd92285">isAvailable</a> ()</td></tr>
<tr class="memdesc:ae3a993de1cf57b8c3f19f2763bd92285"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find out if compute shaders are available.  <a href="#ae3a993de1cf57b8c3f19f2763bd92285">More...</a><br /></td></tr>
<tr class="separator:ae3a993de1cf57b8c3f19f2763bd92285"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:a434a3c214e68ce3ba2e9bd92d3000054"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classfg_1_1_shader.html">Shader</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfg_1_1_compute_shader.html#a434a3c214e68ce3ba2e9bd92d3000054">m_shader</a></td></tr>
<tr class="memdesc:a434a3c214e68ce3ba2e9bd92d3000054"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal shader.  <a href="#a434a3c214e68ce3ba2e9bd92d3000054">More...</a><br /></td></tr>
<tr class="separator:a434a3c214e68ce3ba2e9bd92d3000054"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock">
<p class="definition">Definition at line <a class="el" href="_compute_shader_8hpp_source.html#l00026">26</a> of file <a class="el" href="_compute_shader_8hpp_source.html">ComputeShader.hpp</a>.</p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="aec3751145b5825ef967eedf6e4e57183"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec3751145b5825ef967eedf6e4e57183">&#9670;&nbsp;</a></span>const_reference</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef const <a class="el" href="classfg_1_1_compute_shader.html">ComputeShader</a>&amp; <a class="el" href="classfg_1_1_compute_shader.html#aec3751145b5825ef967eedf6e4e57183">fg::ComputeShader::const_reference</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_compute_shader_8hpp_source.html#l00032">32</a> of file <a class="el" href="_compute_shader_8hpp_source.html">ComputeShader.hpp</a>.</p>

</div>
</div>
<a id="a634948dc3fcdc057ea899190a6f102b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a634948dc3fcdc057ea899190a6f102b4">&#9670;&nbsp;</a></span>reference</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classfg_1_1_compute_shader.html">ComputeShader</a>&amp; <a class="el" href="classfg_1_1_compute_shader.html#a634948dc3fcdc057ea899190a6f102b4">fg::ComputeShader::reference</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="_compute_shader_8hpp_source.html#l00031">31</a> of file <a class="el" href="_compute_shader_8hpp_source.html">ComputeShader.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="ad05555d234c9ae11c6041902ba683fd1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad05555d234c9ae11c6041902ba683fd1">&#9670;&nbsp;</a></span>ComputeShader() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">fg::ComputeShader::ComputeShader </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Default constructor. </p>
<p>After this call the <a class="el" href="classfg_1_1_shader.html" title="Class used to handle OpenGL shader programs in language GLSL ">Shader</a> is uninitialized (invalid) </p>

</div>
</div>
<a id="ab437560a40823c0fafee978c5337c2a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab437560a40823c0fafee978c5337c2a8">&#9670;&nbsp;</a></span>ComputeShader() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">fg::ComputeShader::ComputeShader </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classfg_1_1_compute_shader.html">ComputeShader</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>shader</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Move constructor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">shader</td><td>The shader to move </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a27f461d549bd364326c32cf5af208632"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a27f461d549bd364326c32cf5af208632">&#9670;&nbsp;</a></span>~ComputeShader()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual fg::ComputeShader::~ComputeShader </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default destructor. </p>
<p>Automatically frees OpenGL id </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a63dd54d7c3631c6e341e6ee6d694f3a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63dd54d7c3631c6e341e6ee6d694f3a8">&#9670;&nbsp;</a></span>bind() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fg::ComputeShader::bind </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Bind the shader program for usage. </p>

</div>
</div>
<a id="a7454a834dcccc520d3d7e92dc0872dc6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7454a834dcccc520d3d7e92dc0872dc6">&#9670;&nbsp;</a></span>bind() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void fg::ComputeShader::bind </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classfm_1_1_ref.html">fm::Ref</a>&lt; const <a class="el" href="classfg_1_1_compute_shader.html">ComputeShader</a> &gt;&#160;</td>
          <td class="paramname"><em>program</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Bind a compute shader program for usage. </p>
<p>If <em>program</em> is NULL the current shader program will be unbound</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">program</td><td>The program to be bound </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a54b1ef2b21de8cac1b5f50e4b06a7795"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54b1ef2b21de8cac1b5f50e4b06a7795">&#9670;&nbsp;</a></span>dispatch()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classfm_1_1_result.html">fm::Result</a> fg::ComputeShader::dispatch </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacefm.html#aa61d3cedb1b9d93557d0402c8ee9ea64">fm::vec3s</a>&#160;</td>
          <td class="paramname"><em>workGroupDims</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>run The shader once with given work group dimensions </p>
<p>Same as run</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">workGroupDims</td><td>The dimensions of the workgroup layout</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The result of the operation </dd></dl>

</div>
</div>
<a id="a82729561f71c815baf6491980d791815"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82729561f71c815baf6491980d791815">&#9670;&nbsp;</a></span>fillUniformData()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fg::ComputeShader::fillUniformData </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fill the necessary data about uniforms. </p>
<p>This function is used internally </p>

</div>
</div>
<a id="a6b03c6eb607d94d1c0d3fdc13cfdb51a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b03c6eb607d94d1c0d3fdc13cfdb51a">&#9670;&nbsp;</a></span>forEachUniform()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fg::ComputeShader::forEachUniform </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classfm_1_1_delegate.html">fm::Delegate</a>&lt; void, std::string, <a class="el" href="classfg_1_1_shader.html#a97563a9ceb26ef3bf1db54887026d15c">Shader::UniformData</a> &gt;&#160;</td>
          <td class="paramname"><em>func</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Run a function on all uniforms. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">func</td><td>The function to call </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4e77019323d52eb5457aa855d092200f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e77019323d52eb5457aa855d092200f">&#9670;&nbsp;</a></span>getUniformLocation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int fg::ComputeShader::getUniformLocation </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find the "id" of a uniform. </p>
<p>This function is mostly used internally</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The name of the uniform to find</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>-1 on error, the location otherwise </dd></dl>

</div>
</div>
<a id="a98efaa7fe75be0bff72bdc3acd22d180"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a98efaa7fe75be0bff72bdc3acd22d180">&#9670;&nbsp;</a></span>hasUniform()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int fg::ComputeShader::hasUniform </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if a uniform of a given name is present. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The name of the uniform to find</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on error, the location+1 otherwise </dd></dl>

</div>
</div>
<a id="ae3a993de1cf57b8c3f19f2763bd92285"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3a993de1cf57b8c3f19f2763bd92285">&#9670;&nbsp;</a></span>isAvailable()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool fg::ComputeShader::isAvailable </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find out if compute shaders are available. </p>
<p>You should check for availability before using compute shaders.</p>
<dl class="section return"><dt>Returns</dt><dd>True if compute shaders are available </dd></dl>

</div>
</div>
<a id="ab189cfe837819f456b35b9458a78b26f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab189cfe837819f456b35b9458a78b26f">&#9670;&nbsp;</a></span>isLoaded()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool fg::ComputeShader::isLoaded </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if the shader is successfully loaded. </p>
<dl class="section return"><dt>Returns</dt><dd>True iff the shader is ready to use </dd></dl>

</div>
</div>
<a id="a6c8e257419912d708a9520c2e2333091"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c8e257419912d708a9520c2e2333091">&#9670;&nbsp;</a></span>loadFromFile()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classfm_1_1_result.html">fm::Result</a> fg::ComputeShader::loadFromFile </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>file</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Load the compute shader program a file. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">file</td><td>The name of the file to load from</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The error-state of the function </dd></dl>

</div>
</div>
<a id="af1248a709052227d88134cb066c71e87"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af1248a709052227d88134cb066c71e87">&#9670;&nbsp;</a></span>loadFromMemory() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classfm_1_1_result.html">fm::Result</a> fg::ComputeShader::loadFromMemory </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Load the compute shader program from source stored in memory. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>The surce of the shader</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The error-state of the function </dd></dl>

</div>
</div>
<a id="ae8792266bde6a0d5d107dea5601ea6e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae8792266bde6a0d5d107dea5601ea6e5">&#9670;&nbsp;</a></span>loadFromMemory() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classfm_1_1_result.html">fm::Result</a> fg::ComputeShader::loadFromMemory </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classfg_1_1_shader_source.html">fg::ShaderSource</a> &amp;&#160;</td>
          <td class="paramname"><em>data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Load the shader program from source stored in memory. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>The sources to be compiled</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The error-state of the function </dd></dl>

</div>
</div>
<a id="ad669885b897a14fbf1ad3801a70f503a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad669885b897a14fbf1ad3801a70f503a">&#9670;&nbsp;</a></span>operator=()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classfg_1_1_compute_shader.html">ComputeShader</a>&amp; fg::ComputeShader::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classfg_1_1_compute_shader.html">ComputeShader</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>shader</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Move assignment operator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">shader</td><td>The shader to move </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a548745d90ea6a5127e1ad75b93f95f50"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a548745d90ea6a5127e1ad75b93f95f50">&#9670;&nbsp;</a></span>run()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classfm_1_1_result.html">fm::Result</a> fg::ComputeShader::run </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacefm.html#aa61d3cedb1b9d93557d0402c8ee9ea64">fm::vec3s</a>&#160;</td>
          <td class="paramname"><em>workGroupDims</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>run The shader once with given work group dimensions </p>
<p>Same as dispatch</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">workGroupDims</td><td>The dimensions of the workgroup layout</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The result of the operation </dd></dl>

</div>
</div>
<a id="a5ab46a0a679fb6a553c65368d3b87944"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ab46a0a679fb6a553c65368d3b87944">&#9670;&nbsp;</a></span>setUniform() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classfm_1_1_result.html">fm::Result</a> fg::ComputeShader::setUniform </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the value of a uniform. </p>
<p>If the shader program is invalid no error will be returnes and the shader program will not be modified</p>
<p>This call is forwarded to the internal shader object And then type checked</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The name of the uniform </td></tr>
    <tr><td class="paramname">x</td><td>The value of the uniform</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The error-state of the function </dd></dl>

</div>
</div>
<a id="a1d78a03174d8c13226ffa08bcaf33a6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d78a03174d8c13226ffa08bcaf33a6a">&#9670;&nbsp;</a></span>setUniform() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classfm_1_1_result.html">fm::Result</a> fg::ComputeShader::setUniform </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classfg_1_1_texture.html">Texture</a> &amp;&#160;</td>
          <td class="paramname"><em>tex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>sampler</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the value of an image2D uniform. </p>
<p>If the shader program is invalid no error will be returnes and the shader program will not be modified</p>
<p>Binding as an image is useful when using imageLoad / imageStore</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The name of the uniform </td></tr>
    <tr><td class="paramname">tex</td><td>The value of the uniform </td></tr>
    <tr><td class="paramname">sampler</td><td>Decides whether the texture shall be bound as a sampler or as an image</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The error-state of the function </dd></dl>

</div>
</div>
<a id="a39c8d13ba2bc78d7981ff1409342296d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39c8d13ba2bc78d7981ff1409342296d">&#9670;&nbsp;</a></span>setUniform() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classfm_1_1_result.html">fm::Result</a> fg::ComputeShader::setUniform </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classfg_1_1_texture.html">Texture</a> *&#160;</td>
          <td class="paramname"><em>tex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>sampler</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the value of an image2D uniform. </p>
<p>If the shader program is invalid no error will be returnes and the shader program will not be modified</p>
<p>Binding as an image is useful when using imageLoad / imageStore</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The name of the uniform </td></tr>
    <tr><td class="paramname">tex</td><td>The value of the uniform </td></tr>
    <tr><td class="paramname">sampler</td><td>Decides whether the texture shall be bound as a sampler or as an image</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The error-state of the function </dd></dl>

</div>
</div>
<a id="aad22352eb998cea97b28f9d7e05274b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad22352eb998cea97b28f9d7e05274b5">&#9670;&nbsp;</a></span>setUniform() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classfm_1_1_result.html">fm::Result</a> fg::ComputeShader::setUniform </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classfg_1_1_float_texture.html">FloatTexture</a> &amp;&#160;</td>
          <td class="paramname"><em>tex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>sampler</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the value of an image2D uniform. </p>
<p>If the shader program is invalid no error will be returnes and the shader program will not be modified</p>
<p>Binding as an image is useful when using imageLoad / imageStore</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The name of the uniform </td></tr>
    <tr><td class="paramname">tex</td><td>The value of the uniform </td></tr>
    <tr><td class="paramname">sampler</td><td>Decides whether the texture shall be bound as a sampler or as an image</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The error-state of the function </dd></dl>

</div>
</div>
<a id="a8260c7c3f1716de8d17414f9f249d696"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8260c7c3f1716de8d17414f9f249d696">&#9670;&nbsp;</a></span>setUniform() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classfm_1_1_result.html">fm::Result</a> fg::ComputeShader::setUniform </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classfg_1_1_float_texture.html">FloatTexture</a> *&#160;</td>
          <td class="paramname"><em>tex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>sampler</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the value of an image2D uniform. </p>
<p>If the shader program is invalid no error will be returnes and the shader program will not be modified</p>
<p>Binding as an image is useful when using imageLoad / imageStore</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The name of the uniform </td></tr>
    <tr><td class="paramname">tex</td><td>The value of the uniform </td></tr>
    <tr><td class="paramname">sampler</td><td>Decides whether the texture shall be bound as a sampler or as an image</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The error-state of the function </dd></dl>

</div>
</div>
<a id="a5e4a22f8fdfa17576eb83ec3c7b62da2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e4a22f8fdfa17576eb83ec3c7b62da2">&#9670;&nbsp;</a></span>setUniform() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , fm::Size N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classfm_1_1_result.html">fm::Result</a> fg::ComputeShader::setUniform </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T(&amp;)&#160;</td>
          <td class="paramname"><em>values</em>[N]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the value of an array of uniforms. </p>
<p>If the shader program is invalid no error will be returnes and the shader program will not be modified</p>
<p>The elements od the input array are forwarded one by one as name + "[" + 0..N-1 + "]"</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The name of the uniform </td></tr>
    <tr><td class="paramname">values</td><td>The values</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The error-state of the function </dd></dl>

</div>
</div>
<a id="a77d66de52195d4c9ba94e91afc1d9c14"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77d66de52195d4c9ba94e91afc1d9c14">&#9670;&nbsp;</a></span>swap()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classfg_1_1_compute_shader.html">ComputeShader</a>&amp; fg::ComputeShader::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classfg_1_1_compute_shader.html">ComputeShader</a> &amp;&#160;</td>
          <td class="paramname"><em>shader</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Swap two shaders. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">shader</td><td>The shader to swap with </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a434a3c214e68ce3ba2e9bd92d3000054"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a434a3c214e68ce3ba2e9bd92d3000054">&#9670;&nbsp;</a></span>m_shader</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classfg_1_1_shader.html">Shader</a> fg::ComputeShader::m_shader</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Internal shader. </p>

<p class="definition">Definition at line <a class="el" href="_compute_shader_8hpp_source.html#l00028">28</a> of file <a class="el" href="_compute_shader_8hpp_source.html">ComputeShader.hpp</a>.</p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.14
</small></address>
</body>
</html>
