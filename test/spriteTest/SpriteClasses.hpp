#ifndef SPRITECLASSES_FOR_TEST_HPP
#define SPRITECLASSES_FOR_TEST_HPP

#include <Frontier.hpp>
#include <iostream>
#include <cstring>

using namespace std;

namespace test
{
	class SpriteManager;
	
	#define ImageID int
	
	class Sprite : public Transformable
	{
		SpriteManager *m_manager;
		ImageID m_imgId;
		fm::Size m_id;
		
	protected:
		/////////////////////////////////////////////////////////////
		void setId(fm::Size id);
		
		/////////////////////////////////////////////////////////////
		void destroy();
		
		/////////////////////////////////////////////////////////////
		void setManager(SpriteManager *manager);
		
	public:
		/////////////////////////////////////////////////////////////
		Sprite(SpriteManager &manager,ImageID imgId);
		
		/////////////////////////////////////////////////////////////
		Sprite(const Sprite &sprite);
		
		/////////////////////////////////////////////////////////////
		Sprite(Sprite &&sprite);
		
		/////////////////////////////////////////////////////////////
		Sprite &operator=(const Sprite &sprite);
		
		/////////////////////////////////////////////////////////////
		Sprite &operator=(Sprite &&sprite);
		
		/////////////////////////////////////////////////////////////
		Sprite &swap(Sprite &sprite);
		
		/////////////////////////////////////////////////////////////
		virtual ~Sprite();

		/////////////////////////////////////////////////////////////
		Sprite &setPosition(const fm::vec2 &pos) override;

		/////////////////////////////////////////////////////////////
		Sprite &setSize(const fm::vec2 &size) override;
		
		/////////////////////////////////////////////////////////////
		Sprite &setImgId(ImageID id);
		
		/////////////////////////////////////////////////////////////
		ImageID getImgId() const;
		
		/////////////////////////////////////////////////////////////
		fm::Size getId() const;
		
		/////////////////////////////////////////////////////////////
		SpriteManager *getManager() const;
		
		friend SpriteManager;
	};
	
	
	
	
	
	
	class SpriteManager : public Drawable
	{
	protected:
		std::vector<Sprite *> m_sprites;
		TextureAtlas<ImageID> m_atlas;
		
		/////////////////////////////////////////////////////////////
		virtual void onDestroySprite(Sprite &sprite) = 0;
		
		/////////////////////////////////////////////////////////////
		virtual void onCreateSprite(Sprite &sprite) = 0;
		
		/////////////////////////////////////////////////////////////
		virtual void onRectChangeSprite(Sprite &sprite) = 0;
		
		/////////////////////////////////////////////////////////////
		virtual void onImageChangeSprite(Sprite &sprite) = 0;
		
		/////////////////////////////////////////////////////////////
		virtual void onSwapSprite(Sprite &sprite,Sprite &maybeSprite) = 0;
		
		/////////////////////////////////////////////////////////////
		virtual void onSwapSpriteAfter(Sprite &sprite1,Sprite &sprite2);
		
	public:
		/////////////////////////////////////////////////////////////
		~SpriteManager();
		
		/////////////////////////////////////////////////////////////
		Sprite getSprite(ImageID id);
		
		/////////////////////////////////////////////////////////////
		Sprite &getSpriteById(fm::Size id);
		
		/////////////////////////////////////////////////////////////
		fm::Size getSpriteCount() const;
		
		/////////////////////////////////////////////////////////////
		void addImage(const Image &img,ImageID id,fm::vec2 frameSize = fm::vec2());
		
		/////////////////////////////////////////////////////////////
		fm::vec2 getImageSize(ImageID id) const;
		
		/////////////////////////////////////////////////////////////
		void onUpdate(const fm::Time & /* dt */ ) override {};
		
		/////////////////////////////////////////////////////////////
		void handleSpriteCreate(Sprite &sprite);
		
		/////////////////////////////////////////////////////////////
		void handleSpriteDestroy(Sprite &sprite);
		
		/////////////////////////////////////////////////////////////
		void handleSpriteRectChange(Sprite &sprite);
		
		/////////////////////////////////////////////////////////////
		void handleSpriteImageChange(Sprite &sprite);
		
		/////////////////////////////////////////////////////////////
		void handleSpriteSwap(Sprite &sprite,Sprite &maybeSprite);
		
		/////////////////////////////////////////////////////////////
		void listSprites()
		{
			for (auto s : m_sprites)
			{
				cout << s << " -> " << s->getId() << "(" << s->getPosition() << "), (" << s->getSize() << ")" << endl;
			}
		}
	};
	
	
	class UniqueSpriteManager : public SpriteManager
	{
		/////////////////////////////////////////////////////////////
		void onDestroySprite(Sprite &sprite) override;
		
		/////////////////////////////////////////////////////////////
		void onCreateSprite(Sprite &sprite) override;
		
		/////////////////////////////////////////////////////////////
		void onRectChangeSprite(Sprite &sprite) override;
		
		/////////////////////////////////////////////////////////////
		void onImageChangeSprite(Sprite &sprite) override;
		
		/////////////////////////////////////////////////////////////
		void onSwapSprite(Sprite &sprite,Sprite &maybeSprite) override;
		
		/////////////////////////////////////////////////////////////
		std::vector<fg::DrawData> m_draws;
		
	public:
		UniqueSpriteManager();
		
		/////////////////////////////////////////////////////////////
		virtual void onDraw(ShaderManager &shader) override;
	};
	
	
	class PerOneSpriteManager : public SpriteManager
	{
		/////////////////////////////////////////////////////////////
		void onDestroySprite(Sprite &sprite) override;
		
		/////////////////////////////////////////////////////////////
		void onCreateSprite(Sprite &sprite) override;
		
		/////////////////////////////////////////////////////////////
		void onRectChangeSprite(Sprite &sprite) override;
		
		/////////////////////////////////////////////////////////////
		void onImageChangeSprite(Sprite &sprite) override;
		
		/////////////////////////////////////////////////////////////
		void onSwapSprite(Sprite &sprite,Sprite &maybeSprite) override;
		
		/////////////////////////////////////////////////////////////
		void onSwapSpriteAfter(Sprite &sprite1,Sprite &sprite2) override;
		
		/////////////////////////////////////////////////////////////
		fg::DrawData m_drawData;
		fm::Size m_allocSize;
		
		/////////////////////////////////////////////////////////////
		void updateDrawCount();
		
		/////////////////////////////////////////////////////////////
		void setAllocSize(fm::Size allocSize);
		
	public:
		PerOneSpriteManager();
		
		/////////////////////////////////////////////////////////////
		virtual void onDraw(ShaderManager &shader) override;
	};
	
	
	class MapBufSpriteManager : public SpriteManager
	{
		/////////////////////////////////////////////////////////////
		void onDestroySprite(Sprite &sprite) override;
		
		/////////////////////////////////////////////////////////////
		void onCreateSprite(Sprite &sprite) override;
		
		/////////////////////////////////////////////////////////////
		void onRectChangeSprite(Sprite &sprite) override;
		
		/////////////////////////////////////////////////////////////
		void onImageChangeSprite(Sprite &sprite) override;
		
		/////////////////////////////////////////////////////////////
		void onSwapSprite(Sprite &sprite,Sprite &maybeSprite) override;
		
		/////////////////////////////////////////////////////////////
		void onSwapSpriteAfter(Sprite &sprite1,Sprite &sprite2) override;
		
		/////////////////////////////////////////////////////////////
		fg::DrawData m_drawData;
		fm::Size m_allocSize;
		fm::vec3 *m_ptsPtr;
		fm::vec2 *m_uvsPtr;
		
		/////////////////////////////////////////////////////////////
		void updateDrawCount();
		
		/////////////////////////////////////////////////////////////
		void setAllocSize(fm::Size allocSize);
		
		/////////////////////////////////////////////////////////////
		void unMapPtrs();
		
	public:
		MapBufSpriteManager();
		
		/////////////////////////////////////////////////////////////
		virtual void onDraw(ShaderManager &shader) override;
	};
}

#endif // SPRITECLASSES_FOR_TEST_HPP